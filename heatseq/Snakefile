"""Workflow to analyze HEATseq data
Martin Haagmans https://github.com/zaag
"""

JAVA = '/home/mahaagmans/programs/jre1.8.0_25/bin/java'
TRIMMOMATIC = '/home/mahaagmans/programs/Trimmomatic-0.36/trimmomatic-0.36.jar'
HSQUTILS = '/home/mahaagmans/programs/hsqutils_v1_1/hsqutils.jar'
PROBES = '/home/mahaagmans/Desktop/HEATSEQ/170928_HG19_CLL_AMCv2_HSQ_IRN200341732_probe_info.txt'
REF = '/home/mahaagmans/Documents/referentie/hg19.fa'
SAMTOOLS = '/usr/local/bin/samtools'


DIRSTOMAKE = 'logfiles'

SAMPLES = '18D0997 18D0999 18D1000 18D1001 18D1002 18D1003 18D1004 18D1005 18D1005-100g 18D1005-50ng'.split()

rule prepare:
    input:
        'samples.txt'
    output:
        expand(temp('{sample}.txt'), sample=SAMPLES)
    shell:
        '''for i in $(cat {input}); do
        touch $i.txt ;
        done ;
        '''

rule trim_reads_qual:
    input:
        r1="{sample}.R1.fastq.gz",
        r2="{sample}.R2.fastq.gz",
        txt="{sample}.txt",
    output:
        r1qualfilter=('{sample}_R1_quality_filtered.fastq'),
        r2qualfilter=('{sample}_R2_quality_filtered.fastq'),
        r1unpaired=temp('{sample}_R1_unpaired.fastq'),
        r2unpaired=temp('{sample}_R2_unpaired.fastq'),
    message:
        'Running trimmomatic for {wildcards.sample}'
    log:
        'logfiles/{sample}.trimmomatic.log'
    params:
        trim='HEADCROP:10 CROP:137 MINLEN:125'
    shell:
        '''{JAVA} -jar {TRIMMOMATIC} PE -phred33 {input.r1} {input.r2} \
        {output.r1qualfilter} {output.r1unpaired} \
        {output.r2qualfilter} {output.r2unpaired} \
        {params.trim}  > {log}  2>&1
        '''


# rule trim_reads_primer:
#     input:
#         r1=rules.trim_reads_qual.output.r1qualfilt,
#         r2=rules.trim_reads_qual.output.r2qualfilt
#     output:
#         r1trim=temp('trimmed_{sample}_R1_quality_filtered.fastq'),
#         r2trim=temp('trimmed_{sample}_R2_quality_filtered.fastq')
#     log:
#         'logfiles/{sample}.HSQutils.trim.log'
#     shell:
#         '''{JAVA} -jar {HSQUTILS} trim --r1 {input.r1} --r2 {input.r2} \
#         --probe {PROBES}  > {log}  2>&1
#         '''

rule map_reads:
    input:
        r1=rules.trim_reads_qual.output.r1qualfilter,
        r2=rules.trim_reads_qual.output.r2qualfilter
    output:
        bam='{sample}_qualtrimmed_mapping.bam'
    log:
        'logfiles/{sample}.BWA.log'
    params:
        rg="@RG\\tID:{sample}\\tLB:{sample}\\tPL:ILLUMINA\\tPU:{sample}\\tSM:{sample}"
    shell:
        '''(bwa mem -R "{params.rg}" {REF} -M {input.r1} {input.r2} |\
        {SAMTOOLS} view -Sb - |\
        {SAMTOOLS} sort -T {wildcards.sample}.tmp -O bam - > {output.bam}) > {log} 2>&1
        {SAMTOOLS} index {output.bam}
        '''

# rule dedup_bam:
#     input:
#         r1=rules.trim_reads_qual.output.r1qualfilt,
#         r2=rules.trim_reads_qual.output.r2qualfilt,
#         bam=rules.map_reads.output.bam
#     output:
#         bam='{sample}_dedup.bam'
#     log:
#         'logfiles/{sample}.HSQutils.dedup.log'
#     shell:
#         '''{JAVA} -jar {HSQUTILS} dedup --r1 {input.r1} --r2 {input.r2}  \
#         --inputBam {input.bam} -o {output.bam} --outputPrefix {wildcards.sample} \
#         --probe {PROBES}  > {log}  2>&1
#         samtools index {output.bam}
#         '''

rule END:
    input:
        expand(rules.map_reads.output.bam, sample=SAMPLES)


# $SAMTOOLS mpileup -Bugf $REF $SAMPLE\_dedup.bam -l $TARGET | $BCFTOOLS call -vm -O u -o $SAMPLE.raw.bcf

# $BCFTOOLS filter -i 'MQ>=30 && DP>=10 && DP<=50000' $SAMPLE.raw.bcf > $SAMPLE.filtered.vcf
